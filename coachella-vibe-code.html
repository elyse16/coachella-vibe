<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>COACHELLA</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Dela+Gothic+One&family=DM+Sans:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap');

  :root {
    --sunset-orange: #FF6B35;
    --desert-gold: #F7C548;
    --palm-green: #2D6A4F;
    --night-purple: #5A189A;
    --hot-pink: #FF006E;
    --deep-black: #0A0A0A;
    --sand: #FAF0E6;
    --glass: rgba(255,255,255,0.07);
    --glass-border: rgba(255,255,255,0.12);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'DM Sans', sans-serif;
    background: var(--deep-black);
    color: #fff;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Animated gradient background */
  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background:
      radial-gradient(ellipse at 20% 50%, rgba(90,24,154,0.3) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 20%, rgba(255,107,53,0.2) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 80%, rgba(255,0,110,0.15) 0%, transparent 50%);
    z-index: 0;
    animation: bgShift 15s ease-in-out infinite alternate;
  }

  @keyframes bgShift {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
  }

  /* ── HEADER ── */
  .header {
    text-align: center;
    padding: 40px 0 20px;
  }

  .header h1 {
    font-family: 'Dela Gothic One', cursive;
    font-size: clamp(2rem, 6vw, 3.5rem);
    background: linear-gradient(135deg, var(--desert-gold), var(--sunset-orange), var(--hot-pink));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: 2px;
    line-height: 1.1;
  }

  .header .subtitle {
    font-size: 0.95rem;
    color: rgba(255,255,255,0.5);
    margin-top: 8px;
    font-weight: 300;
    letter-spacing: 3px;
    text-transform: uppercase;
  }

  /* ── LOGIN SCREEN ── */
  #login-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 60vh;
    text-align: center;
    gap: 30px;
  }

  .login-card {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 24px;
    padding: 50px 40px;
    backdrop-filter: blur(20px);
    max-width: 480px;
    width: 100%;
  }

  .login-card p {
    color: rgba(255,255,255,0.6);
    font-size: 1rem;
    line-height: 1.6;
    margin-bottom: 30px;
  }

  .btn-spotify {
    display: inline-flex;
    align-items: center;
    gap: 12px;
    background: #1DB954;
    color: #fff;
    border: none;
    border-radius: 50px;
    padding: 16px 36px;
    font-family: 'DM Sans', sans-serif;
    font-size: 1.05rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 0.5px;
  }

  .btn-spotify:hover {
    background: #1ed760;
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(29,185,84,0.4);
  }

  .btn-spotify svg { width: 24px; height: 24px; }

  /* ── STATS BAR ── */
  .stats-bar {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
    margin: 20px 0;
  }

  .stat-chip {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 12px;
    padding: 10px 18px;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .stat-chip .num {
    font-weight: 700;
    font-size: 1.1rem;
    color: var(--desert-gold);
  }

  .stat-chip .label {
    color: rgba(255,255,255,0.5);
    font-weight: 300;
  }

  /* ── NOW PLAYING ── */
  #player-section { display: none; }

  .now-playing {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 24px;
    padding: 30px;
    backdrop-filter: blur(20px);
    text-align: center;
    margin: 20px 0;
    position: relative;
    overflow: hidden;
  }

  .now-playing::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 3px;
    background: linear-gradient(90deg, var(--sunset-orange), var(--hot-pink), var(--night-purple));
  }

  .np-label {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 4px;
    color: rgba(255,255,255,0.4);
    margin-bottom: 20px;
  }

  .np-album-art {
    width: 200px;
    height: 200px;
    border-radius: 16px;
    margin: 0 auto 20px;
    background: rgba(255,255,255,0.05);
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  }

  .np-album-art img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .np-track-name {
    font-size: 1.4rem;
    font-weight: 700;
    margin-bottom: 6px;
    color: #fff;
  }

  .np-artist-name {
    font-size: 1rem;
    color: var(--desert-gold);
    font-weight: 500;
    margin-bottom: 4px;
  }

  .np-artist-count {
    font-size: 0.8rem;
    color: rgba(255,255,255,0.35);
    margin-bottom: 20px;
  }

  /* Playback controls */
  .playback-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
    margin-bottom: 24px;
  }

  .ctrl-btn {
    background: none;
    border: none;
    color: rgba(255,255,255,0.6);
    cursor: pointer;
    transition: all 0.2s;
    padding: 8px;
    border-radius: 50%;
  }

  .ctrl-btn:hover { color: #fff; background: rgba(255,255,255,0.1); }

  .ctrl-btn.play-pause {
    background: #fff;
    color: var(--deep-black);
    width: 56px;
    height: 56px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
  }

  .ctrl-btn.play-pause:hover {
    transform: scale(1.08);
    background: var(--desert-gold);
  }

  /* ── RATING STARS ── */
  .rating-section {
    margin-top: 10px;
  }

  .rating-prompt {
    font-size: 0.85rem;
    color: rgba(255,255,255,0.4);
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  .stars {
    display: flex;
    justify-content: center;
    gap: 8px;
  }

  .star-btn {
    background: none;
    border: 2px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.25);
    width: 56px;
    height: 56px;
    border-radius: 14px;
    font-size: 1.3rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: 'DM Sans', sans-serif;
  }

  .star-btn:hover {
    border-color: var(--desert-gold);
    color: var(--desert-gold);
    background: rgba(247,197,72,0.1);
    transform: translateY(-3px);
  }

  .star-btn.active {
    background: var(--desert-gold);
    border-color: var(--desert-gold);
    color: var(--deep-black);
    font-weight: 700;
  }

  /* ── SKIP ── */
  .skip-btn {
    background: none;
    border: 1px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.4);
    border-radius: 50px;
    padding: 10px 28px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.85rem;
    cursor: pointer;
    margin-top: 16px;
    transition: all 0.2s;
  }

  .skip-btn:hover {
    border-color: rgba(255,255,255,0.3);
    color: rgba(255,255,255,0.7);
  }

  /* ── TABS ── */
  .tab-bar {
    display: flex;
    gap: 0;
    margin: 20px 0 0;
    border-bottom: 1px solid rgba(255,255,255,0.1);
  }

  .tab-btn {
    background: none;
    border: none;
    color: rgba(255,255,255,0.4);
    padding: 14px 24px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
  }

  .tab-btn.active {
    color: var(--desert-gold);
    border-bottom-color: var(--desert-gold);
  }

  .tab-btn:hover:not(.active) { color: rgba(255,255,255,0.7); }

  /* ── LEADERBOARD ── */
  .leaderboard {
    margin-top: 16px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .lb-row {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    border-radius: 12px;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    transition: all 0.3s;
    gap: 14px;
  }

  .lb-row.eliminated {
    opacity: 0.35;
    border-color: rgba(255,0,0,0.15);
  }

  .lb-row.eliminated .lb-status { color: #ff4444; }

  .lb-rank {
    font-weight: 700;
    font-size: 0.85rem;
    color: rgba(255,255,255,0.3);
    min-width: 28px;
    text-align: center;
  }

  .lb-info { flex: 1; min-width: 0; }

  .lb-name {
    font-weight: 600;
    font-size: 0.95rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .lb-meta {
    font-size: 0.75rem;
    color: rgba(255,255,255,0.35);
    margin-top: 2px;
  }

  .lb-avg {
    font-weight: 700;
    font-size: 1.1rem;
    color: var(--desert-gold);
    min-width: 40px;
    text-align: right;
  }

  .lb-status {
    font-size: 0.75rem;
    font-weight: 600;
    min-width: 60px;
    text-align: center;
    padding: 4px 10px;
    border-radius: 6px;
  }

  .lb-status.kept { color: #2D6A4F; background: rgba(45,106,79,0.15); }
  .lb-status.pending { color: rgba(255,255,255,0.3); }
  .lb-status.eliminated { color: #ff4444; background: rgba(255,0,0,0.1); }

  /* ── ELIMINATED TAB ── */
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* ── FINISH BUTTON ── */
  .finish-section {
    text-align: center;
    margin: 30px 0;
  }

  .btn-finish {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    background: linear-gradient(135deg, var(--sunset-orange), var(--hot-pink));
    color: #fff;
    border: none;
    border-radius: 50px;
    padding: 16px 36px;
    font-family: 'DM Sans', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .btn-finish:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(255,0,110,0.3);
  }

  .btn-finish:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  /* ── RESULTS SCREEN ── */
  #results-screen { display: none; }

  .results-card {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 24px;
    padding: 40px;
    backdrop-filter: blur(20px);
    text-align: center;
    margin: 20px 0;
  }

  .results-card h2 {
    font-family: 'Dela Gothic One', cursive;
    font-size: 1.8rem;
    background: linear-gradient(135deg, var(--desert-gold), var(--hot-pink));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 10px;
  }

  .results-card p {
    color: rgba(255,255,255,0.5);
    margin-bottom: 20px;
  }

  .btn-playlist {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    background: #1DB954;
    color: #fff;
    border: none;
    border-radius: 50px;
    padding: 14px 32px;
    font-family: 'DM Sans', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 10px;
  }

  .btn-playlist:hover {
    background: #1ed760;
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(29,185,84,0.4);
  }

  .btn-restart {
    background: none;
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.6);
    border-radius: 50px;
    padding: 12px 28px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.9rem;
    cursor: pointer;
    margin-top: 16px;
    transition: all 0.2s;
  }

  .btn-restart:hover {
    border-color: rgba(255,255,255,0.4);
    color: #fff;
  }

  /* ── LOADING ── */
  .loading-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(10,10,10,0.9);
    z-index: 100;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 20px;
  }

  .loading-overlay.active { display: flex; }

  .spinner {
    width: 48px;
    height: 48px;
    border: 3px solid rgba(255,255,255,0.1);
    border-top-color: var(--desert-gold);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-text {
    color: rgba(255,255,255,0.5);
    font-size: 0.9rem;
  }

  /* ── TOAST ── */
  .toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    background: var(--glass);
    border: 1px solid var(--glass-border);
    backdrop-filter: blur(20px);
    padding: 14px 28px;
    border-radius: 14px;
    font-size: 0.9rem;
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    z-index: 200;
    text-align: center;
    max-width: 90%;
  }

  .toast.show { transform: translateX(-50%) translateY(0); }
  .toast.eliminated-toast { border-color: rgba(255,68,68,0.3); }
  .toast.kept-toast { border-color: rgba(45,106,79,0.3); }

  /* ── PROGRESS BAR ── */
  .progress-bar {
    width: 100%;
    height: 4px;
    background: rgba(255,255,255,0.05);
    border-radius: 2px;
    margin: 16px 0;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--sunset-orange), var(--hot-pink));
    border-radius: 2px;
    transition: width 0.5s ease;
    width: 0%;
  }

  /* ── ERROR ── */
  .error-msg {
    background: rgba(255,68,68,0.1);
    border: 1px solid rgba(255,68,68,0.2);
    border-radius: 12px;
    padding: 16px 20px;
    margin: 16px 0;
    font-size: 0.9rem;
    color: #ff8888;
    text-align: center;
    display: none;
  }

  .error-msg.show { display: block; }

  /* ── COMMUNITY TAB ── */
  .community-artist-row {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    border-radius: 12px;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    gap: 14px;
    margin-bottom: 6px;
  }

  .community-raters {
    font-size: 0.75rem;
    color: rgba(255,255,255,0.4);
    margin-top: 4px;
  }

  .community-raters span {
    cursor: pointer;
    transition: color 0.2s;
  }

  .community-raters span:hover {
    color: var(--desert-gold);
    text-decoration: underline;
  }

  .user-detail-header {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 20px;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    margin-bottom: 16px;
  }

  .user-detail-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: rgba(255,255,255,0.1);
    overflow: hidden;
    flex-shrink: 0;
  }

  .user-detail-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .user-detail-name {
    font-weight: 700;
    font-size: 1.1rem;
  }

  .user-detail-meta {
    font-size: 0.8rem;
    color: rgba(255,255,255,0.4);
    margin-top: 2px;
  }

  .back-btn {
    background: none;
    border: 1px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.5);
    border-radius: 8px;
    padding: 6px 14px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.8rem;
    cursor: pointer;
    margin-left: auto;
    transition: all 0.2s;
  }

  .back-btn:hover {
    border-color: rgba(255,255,255,0.3);
    color: #fff;
  }

  .top-raters {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 20px;
  }

  .rater-chip {
    display: flex;
    align-items: center;
    gap: 8px;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 10px;
    padding: 8px 14px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .rater-chip:hover {
    border-color: var(--desert-gold);
    background: rgba(247,197,72,0.08);
  }

  .rater-chip img {
    width: 28px;
    height: 28px;
    border-radius: 50%;
  }

  .rater-chip .rater-name {
    font-size: 0.85rem;
    font-weight: 600;
  }

  .rater-chip .rater-count {
    font-size: 0.75rem;
    color: rgba(255,255,255,0.4);
  }

  /* ── RESPONSIVE ── */
  @media (max-width: 600px) {
    .container { padding: 12px; }
    .now-playing { padding: 20px; }
    .np-album-art { width: 160px; height: 160px; }
    .star-btn { width: 48px; height: 48px; font-size: 1.1rem; }
    .login-card { padding: 30px 20px; }
    .lb-row { padding: 10px 12px; gap: 10px; }
  }
</style>
</head>
<body>

<div class="container">
  <!-- HEADER -->
  <div class="header">
    <h1>COACHELLA</h1>
    <div class="subtitle">2026 · Taste Test Your Lineup</div>
  </div>

  <!-- LOGIN SCREEN -->
  <div id="login-screen">
    <div class="login-card">
      <p>Connect your Spotify Premium account to play songs from every Coachella 2026 artist. Rate each track, eliminate the ones that don't vibe, and build your dream lineup.</p>
      <button class="btn-spotify" onclick="loginSpotify()">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
        Connect with Spotify
      </button>
    </div>
  </div>

  <!-- PLAYER SECTION -->
  <div id="player-section">
    <!-- Stats -->
    <div class="stats-bar">
      <div class="stat-chip">
        <span class="num" id="stat-remaining">0</span>
        <span class="label">in play</span>
      </div>
      <div class="stat-chip">
        <span class="num" id="stat-eliminated">0</span>
        <span class="label">eliminated</span>
      </div>
      <div class="stat-chip">
        <span class="num" id="stat-rated">0</span>
        <span class="label">songs rated</span>
      </div>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>

    <!-- Now Playing Card -->
    <div class="now-playing">
      <div class="np-label">Now Playing</div>
      <div class="np-album-art">
        <img id="np-art" src="" alt="Album art">
      </div>
      <div class="np-track-name" id="np-track">Loading...</div>
      <div class="np-artist-name" id="np-artist">—</div>
      <div class="np-artist-count" id="np-count"></div>

      <!-- Playback Controls -->
      <div class="playback-controls">
        <button class="ctrl-btn" onclick="previousTrack()" title="Previous">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
        </button>
        <button class="ctrl-btn play-pause" id="play-pause-btn" onclick="togglePlayPause()">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="play-icon" style="display:none"><path d="M8 5v14l11-7z"/></svg>
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="pause-icon"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
        </button>
        <button class="ctrl-btn" onclick="skipToNext()" title="Next">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
        </button>
      </div>

      <!-- Rating -->
      <div class="rating-section">
        <div class="rating-prompt">Rate this track</div>
        <div class="stars">
          <button class="star-btn" onclick="rate(1)">1</button>
          <button class="star-btn" onclick="rate(2)">2</button>
          <button class="star-btn" onclick="rate(3)">3</button>
          <button class="star-btn" onclick="rate(4)">4</button>
          <button class="star-btn" onclick="rate(5)">5</button>
        </div>
        <button class="skip-btn" onclick="skipSong()">Skip (don't rate)</button>
      </div>
    </div>

    <div id="error-msg" class="error-msg"></div>

    <!-- Tabs -->
    <div class="tab-bar">
      <button class="tab-btn active" onclick="switchTab('active')">Active</button>
      <button class="tab-btn" onclick="switchTab('eliminated')">Eliminated</button>
      <button class="tab-btn" onclick="switchTab('all')">All Artists</button>
      <button class="tab-btn" onclick="switchTab('community')">Community</button>
    </div>

    <div id="tab-active" class="tab-content active">
      <div class="leaderboard" id="leaderboard-active"></div>
    </div>
    <div id="tab-eliminated" class="tab-content">
      <div class="leaderboard" id="leaderboard-eliminated"></div>
    </div>
    <div id="tab-all" class="tab-content">
      <div class="leaderboard" id="leaderboard-all"></div>
    </div>
    <div id="tab-community" class="tab-content">
      <div id="community-content"></div>
    </div>

    <!-- Finish -->
    <div class="finish-section">
      <button class="btn-finish" id="btn-finish" onclick="finishSession()" disabled>
        Finish & Create Playlist
      </button>
      <div style="font-size:0.75rem; color:rgba(255,255,255,0.3); margin-top:8px;">
        Available after all artists have 3+ ratings
      </div>
    </div>
  </div>

  <!-- RESULTS SCREEN -->
  <div id="results-screen">
    <div class="results-card">
      <h2>YOUR LINEUP</h2>
      <p id="results-summary"></p>
      <button class="btn-playlist" id="btn-create-playlist" onclick="createPlaylist()">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
        Create Spotify Playlist
      </button>
      <br>
      <button class="btn-restart" onclick="restartSession()">Start Over</button>
    </div>
    <div class="leaderboard" id="results-leaderboard"></div>
  </div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loading">
  <div class="spinner"></div>
  <div class="loading-text" id="loading-text">Loading your Coachella lineup...</div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>
<script src="https://sdk.scdn.co/spotify-player.js"></script>
<script>
// ═══════════════════════════════════════════
// FIREBASE CONFIG
// ═══════════════════════════════════════════
const firebaseConfig = {
  apiKey: "AIzaSyB27zf7Co9WpyB8FgmWYfIvwwGZiss_3QI",
  authDomain: "coachella-vibes.firebaseapp.com",
  projectId: "coachella-vibes",
  storageBucket: "coachella-vibes.firebasestorage.app",
  messagingSenderId: "736899142333",
  appId: "1:736899142333:web:9bb61b3b83e12a494c1dd4"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ═══════════════════════════════════════════
// CONFIG
// ═══════════════════════════════════════════
const CLIENT_ID = 'a9efe27c3e7e4ba09df58d3b6e4448de';
// Must match one of your Spotify Developer App redirect URIs exactly.
// Supports both GitHub Pages (/coachella-vibe) and localhost root.
const APP_BASE_PATH = window.location.pathname.startsWith('/coachella-vibe') ? '/coachella-vibe' : '';
const REDIRECT_URI = `${window.location.origin}${APP_BASE_PATH}/callback`;
const SCOPES = [
  'user-read-private',
  'user-read-email',
  'user-read-playback-state',
  'user-modify-playback-state',
  'user-read-currently-playing',
  'playlist-modify-public',
  'playlist-modify-private',
  'streaming'
].join(' ');

const MIN_RATINGS = 3;
const ELIMINATION_THRESHOLD = 3.0;

// ═══════════════════════════════════════════
// COACHELLA 2026 LINEUP
// ═══════════════════════════════════════════
const COACHELLA_ARTISTS = [
  // Weekend 1 headliners & top billing
  "Sabrina Carpenter", "The xx", "Nine Inch Noize", "Disclosure",
  "Turnstile", "Ethel Cain", "Dijon", "Teddy Swims",
  "KATSEYE", "Devo", "Sexyy Red", "Central Cee",
  "Foster the People", "Levity", "Blood Orange", "Moby",
  "Marlon Hoffstadt", "Lykke Li", "fakemink", "Gordo",
  "Creepy Nuts", "Joyce Manor", "BINI", "Kettama",
  "Groove Armada", "Joost", "HUGEL", "CMAT",
  "Slayyyter", "Prospa", "Hot Mulligan", "Hamdi",
  "Fleshwater", "Max Styler", "Wednesday", "Dabeull",
  "The Two Lips", "Ninajirachi", "Max Dean x Luke Dean",
  "Cachirula & Loojan", "Jessica Brankka", "Chloé Caillet x Rossi.",
  "Arodes", "NewDad", "Carolina Durante", "flowerovlove",
  "Febuary", "Bob Baker Marionettes", "Youna", "Sahar Z",
  // Weekend 2 headliners & top billing
  "Justin Bieber", "The Strokes", "GIVĒON", "Addison Rae",
  "Labrinth", "SOMBR", "David Byrne", "Interpol",
  "Alex G", "Swae Lee", "Solomun", "Taemin",
  "PinkPantheress", "Royel Otis", "REZZ", "Fujii Kaze",
  "Adriatique", "Davido", "Boys Noize", "Geese",
  "rusowsky", "Green Velvet x AYYBO", "Luísa Sonza", "ZULAN",
  "Los Hermanos Flores", "Bedouin", "Ceremony", "54 Ultra",
  "Noga Erez", "Ben Sterling", "Blondshell", "Lambrini Girls",
  "Ecca Vandal", "Mind Enterprises", "Freak Slug", "SOSA",
  "Mahmut Orhan", "Riordan", "Die Spitz", "WHATMORE",
  "GENESI", "Yamagucci",
  // Weekend 3 headliners & top billing
  "Karol G", "Young Thug", "Kaskade", "BIGBANG",
  "Laufey", "Major Lazer", "Iggy Pop", "FKA twigs",
  "Wet Leg", "Clipse", "Subtronics", "Little Simz",
  "Mochakk", "Duke Dumont", "Worship",
  "Armin van Buuren x Adam Beyer", "Holly Humberstone",
  "Gigi Perez", "The Rapture", "Suicidal Tendencies",
  "BUNT.", "French Police", "Black Flag", "Oklou",
  "Röyksopp", "The Chats", "DRAIN", "Model/Actriz",
  "COBRAH", "Los Retros", "WhoMadeWho", "Jane Remover",
  "RØZ", "Glitterer", "Carlita x Josh Baker", "MËSTIZA",
  "&friends", "AZZECCA", "LE YORA", "Samia", "Tomora"
];

// ═══════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════
let accessToken = null;
let refreshToken = null;
let userId = null;
let userDisplayName = null;
let userAvatar = null;
let userEmail = null;
let artists = {};
let songQueue = [];
let currentSong = null;
let isPlaying = false;
let totalRated = 0;
let deviceId = null;

// ═══════════════════════════════════════════
// FIRESTORE HELPERS
// ═══════════════════════════════════════════
async function fbUpsertUser(spotifyId, displayName, avatarUrl, email) {
  try {
    const userData = {
      display_name: displayName || 'Unknown',
      avatar_url: avatarUrl || '',
      last_seen: firebase.firestore.FieldValue.serverTimestamp()
    };
    if (email) userData.email = email;
    await db.collection('users').doc(spotifyId).set(userData, { merge: true });
  } catch (e) { console.warn('Firebase user upsert failed:', e); }
}

async function fbSaveRating(spotifyId, artistName, trackId, trackName, score) {
  try {
    const docId = `${spotifyId}_${trackId}`;
    await db.collection('ratings').doc(docId).set({
      spotify_id: spotifyId,
      artist_name: artistName,
      track_id: trackId,
      track_name: trackName,
      score: score,
      created_at: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  } catch (e) { console.warn('Firebase rating save failed:', e); }
}

async function fbLoadUserRatings(spotifyId) {
  try {
    const snap = await db.collection('ratings')
      .where('spotify_id', '==', spotifyId).get();
    return snap.docs.map(d => d.data());
  } catch (e) {
    console.warn('Firebase load ratings failed:', e);
    return [];
  }
}

async function fbLoadAllRatings() {
  try {
    const snap = await db.collection('ratings').get();
    return snap.docs.map(d => d.data());
  } catch (e) {
    console.warn('Firebase load all ratings failed:', e);
    return [];
  }
}

async function fbLoadAllUsers() {
  try {
    const snap = await db.collection('users').get();
    const users = {};
    snap.docs.forEach(d => { users[d.id] = d.data(); });
    return users;
  } catch (e) {
    console.warn('Firebase load users failed:', e);
    return {};
  }
}

// ═══════════════════════════════════════════
// FIRESTORE TRACK CACHE (shared across all users)
// ═══════════════════════════════════════════
const TRACK_CACHE_DOC = 'coachella_2026';
const TRACK_CACHE_TTL_HOURS = 168;
const MIN_CACHE_ARTISTS = Math.max(20, Math.floor(COACHELLA_ARTISTS.length * 0.6));

function countArtistsWithTracks(cacheData) {
  if (!cacheData || typeof cacheData !== 'object') return 0;
  return COACHELLA_ARTISTS.reduce((count, name) => {
    const c = cacheData[name];
    return count + (c && Array.isArray(c.tracks) && c.tracks.length > 0 ? 1 : 0);
  }, 0);
}

function isUsableTrackCache(cacheData) {
  return countArtistsWithTracks(cacheData) >= MIN_CACHE_ARTISTS;
}

async function fbGetTrackCache() {
  try {
    const doc = await db.collection('track_cache').doc(TRACK_CACHE_DOC).get();
    if (!doc.exists) return null;
    const cache = doc.data();
    const ageHours = (Date.now() - (cache.updated_at?.toMillis() || 0)) / 3600000;
    if (ageHours > TRACK_CACHE_TTL_HOURS) return null;
    return cache.data;
  } catch (e) {
    console.warn('Firestore track cache read failed:', e);
    return null;
  }
}

async function fbSaveTrackCache(data) {
  try {
    await db.collection('track_cache').doc(TRACK_CACHE_DOC).set({
      data: data,
      updated_at: firebase.firestore.FieldValue.serverTimestamp(),
      artist_count: Object.keys(data).length
    });
  } catch (e) { console.warn('Firestore track cache save failed:', e); }
}

// ═══════════════════════════════════════════
// AUTH
// ═══════════════════════════════════════════
function loginSpotify() {
  // Generate PKCE verifier and challenge
  const verifier = generateRandomString(128);
  localStorage.setItem('pkce_verifier', verifier);

  generateCodeChallenge(verifier).then(challenge => {
    const params = new URLSearchParams({
      client_id: CLIENT_ID,
      response_type: 'code',
      redirect_uri: REDIRECT_URI,
      scope: SCOPES,
      code_challenge_method: 'S256',
      code_challenge: challenge,
      show_dialog: 'true'
    });
    window.location.href = 'https://accounts.spotify.com/authorize?' + params.toString();
  });
}

function generateRandomString(length) {
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  const values = crypto.getRandomValues(new Uint8Array(length));
  return values.reduce((acc, x) => acc + possible[x % possible.length], '');
}

async function generateCodeChallenge(verifier) {
  const data = new TextEncoder().encode(verifier);
  const digest = await crypto.subtle.digest('SHA-256', data);
  return btoa(String.fromCharCode(...new Uint8Array(digest)))
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function exchangeCode(code) {
  const verifier = localStorage.getItem('pkce_verifier');
  const response = await fetch('https://accounts.spotify.com/api/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: CLIENT_ID,
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: REDIRECT_URI,
      code_verifier: verifier
    })
  });
  const data = await response.json();
  if (data.access_token) {
    accessToken = data.access_token;
    if (data.refresh_token) {
      refreshToken = data.refresh_token;
      localStorage.setItem('spotify_refresh_token', refreshToken);
    }
    localStorage.setItem('spotify_token', accessToken);
    localStorage.setItem('spotify_token_time', Date.now().toString());
    localStorage.setItem('spotify_scopes', SCOPES);
    window.history.replaceState({}, document.title, REDIRECT_URI);
    await initApp();
  } else {
    showError('Failed to authenticate with Spotify. Please try again.');
    console.error('Token exchange failed:', data);
  }
}

async function refreshAccessToken() {
  const stored = localStorage.getItem('spotify_refresh_token');
  if (!stored) return false;
  try {
    const response = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        client_id: CLIENT_ID,
        grant_type: 'refresh_token',
        refresh_token: stored
      })
    });
    const data = await response.json();
    if (data.access_token) {
      accessToken = data.access_token;
      localStorage.setItem('spotify_token', accessToken);
      localStorage.setItem('spotify_token_time', Date.now().toString());
      if (data.refresh_token) {
        refreshToken = data.refresh_token;
        localStorage.setItem('spotify_refresh_token', refreshToken);
      }
      return true;
    }
  } catch (e) { console.warn('Token refresh failed:', e); }
  return false;
}

// ═══════════════════════════════════════════
// SPOTIFY API HELPERS
// ═══════════════════════════════════════════
const SPOTIFY_RETRY_MAX = 5;
let apiDelayMs = 2000;
let globalRateLimitUntilMs = 0;
let spotifyRateLimitTriggered = false;
const ARTIST_SEARCH_BATCH_SIZE = 8;
const INITIAL_ARTIST_LOAD_COUNT = 20;
const SUBSEQUENT_STAGE_ARTIST_COUNT = 24;
const STAGE_DELAY_MS = 30000;
const MIN_SEARCH_SPACING_MS = 6000;

let isRefreshing = false;

async function spotifyFetch(endpoint, options = {}, retriesLeft = SPOTIFY_RETRY_MAX) {
  const now = Date.now();
  if (now < globalRateLimitUntilMs) {
    await sleep(globalRateLimitUntilMs - now);
  }
  const url = endpoint.startsWith('http') ? endpoint : `https://api.spotify.com/v1${endpoint}`;
  const res = await fetch(url, {
    ...options,
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
      ...options.headers
    }
  });
  if (res.status === 401 && !isRefreshing) {
    isRefreshing = true;
    const refreshed = await refreshAccessToken();
    isRefreshing = false;
    if (refreshed) return spotifyFetch(endpoint, options, retriesLeft);
    showError('Session expired. Please reconnect.');
    document.getElementById('login-screen').style.display = 'flex';
    document.getElementById('player-section').style.display = 'none';
    return null;
  }
  if (res.status === 204 || res.status === 202) return {};
  if (res.status === 429 && retriesLeft > 0) {
    const retrySec = res.headers.get('Retry-After');
    const parsedRetrySec = retrySec ? parseInt(retrySec, 10) : NaN;
    const waitMs = Number.isFinite(parsedRetrySec) && parsedRetrySec > 0
      ? parsedRetrySec * 1000
      : Math.max(20000, 5000 * Math.pow(2, SPOTIFY_RETRY_MAX - retriesLeft));
    globalRateLimitUntilMs = Date.now() + waitMs;
    spotifyRateLimitTriggered = true;
    apiDelayMs = Math.min(apiDelayMs * 2, 8000);
    console.log(`Rate limited — waiting ${Math.round(waitMs/1000)}s (delay now ${apiDelayMs}ms)`);
    // Search is the hottest endpoint; fail fast and let outer flow cool down.
    if (endpoint.includes('/search')) return null;
    // Honor Retry-After/global gate before retrying non-search calls.
    await sleep(waitMs);
    return spotifyFetch(endpoint, options, retriesLeft - 1);
  }
  if (res.status === 403) {
    const err = await res.json().catch(() => ({}));
    console.error('Spotify 403 Forbidden:', endpoint, err);
    return null;
  }
  if (!res.ok) {
    const err = await res.json().catch(() => ({}));
    console.error('Spotify API error:', res.status, err);
    return null;
  }
  return res.json();
}

// ═══════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════
let loadingInBackground = false;

async function initApp() {
  showLoading('Connecting to Spotify...');
  document.getElementById('login-screen').style.display = 'none';
  document.getElementById('player-section').style.display = 'block';

  const me = await spotifyFetch('/me');
  if (!me) { hideLoading(); return; }
  userId = me.id;
  userDisplayName = me.display_name || me.id;
  userAvatar = (me.images && me.images.length > 0) ? me.images[0].url : '';
  userEmail = me.email || null;

  fbUpsertUser(userId, userDisplayName, userAvatar, userEmail);

  // Start in-browser Spotify player (skip in embedded browsers without DRM support)
  if (isEmbeddedBrowser) {
    webPlayerUnsupported = true;
    console.warn('Embedded browser detected, skipping Spotify Web Playback SDK');
    showError('Embedded browser detected. For full playback support, open in Chrome or Safari.');
  } else {
    showLoading('Starting Spotify player...');
    const playerReady = await initWebPlayer();
    if (!playerReady) {
      await ensureDevice();
    }
  }

  // Try restoring from Firebase first, then local storage fallback
  showLoading('Restoring your ratings...');
  const savedRatings = await fbLoadUserRatings(userId);
  if (savedRatings && savedRatings.length > 0) {
    // Rebuild artist state from Firebase ratings
    const ratingsByArtist = {};
    for (const r of savedRatings) {
      if (!ratingsByArtist[r.artist_name]) ratingsByArtist[r.artist_name] = [];
      ratingsByArtist[r.artist_name].push(r);
    }
    for (const [name, ratings] of Object.entries(ratingsByArtist)) {
      if (!artists[name]) {
        artists[name] = { spotifyId: '', tracks: [], ratings: [], eliminated: false, avgRating: 0 };
      }
      artists[name].ratings = ratings.map(r => ({
        trackId: r.track_id,
        trackName: r.track_name,
        score: r.score
      }));
      const avg = ratings.reduce((a, r) => a + r.score, 0) / ratings.length;
      artists[name].avgRating = Math.round(avg * 10) / 10;
      if (ratings.length >= MIN_RATINGS && avg < ELIMINATION_THRESHOLD) artists[name].eliminated = true;
    }
    totalRated = savedRatings.length;
    updateStats();
    renderLeaderboards();
    checkFinishEligibility();
    hideLoading();
    // Still load tracks in background for playback
    loadArtistTracksInBackground();
    return;
  }

  // Local storage fallback
  const saved = localStorage.getItem('vibe_session');
  if (saved) {
    try {
      const session = JSON.parse(saved);
      const savedArtistCount = countArtistsWithTracks(session.artists);
      if (savedArtistCount < MIN_CACHE_ARTISTS) {
        console.warn(`Ignoring incomplete saved session (${savedArtistCount} artists)`);
        localStorage.removeItem('vibe_session');
      } else {
      artists = session.artists;
      totalRated = session.totalRated;
      songQueue = session.songQueue || [];
      if (songQueue.length === 0) buildQueue();
      updateStats();
      renderLeaderboards();
      checkFinishEligibility();
      hideLoading();
      playNext();
      return;
      }
    } catch(e) {
      console.log('Could not restore session, starting fresh');
      localStorage.removeItem('vibe_session');
    }
  }

  // No saved session: start loading artists in the background
  hideLoading();
  loadArtistTracksInBackground();
}

function getTrackCache() {
  try {
    const raw = localStorage.getItem('track_cache');
    if (!raw) return null;
    const cache = JSON.parse(raw);
    const ageHours = (Date.now() - (cache.ts || 0)) / 3600000;
    if (ageHours > 24) { localStorage.removeItem('track_cache'); return null; }
    return cache.data;
  } catch { return null; }
}

function saveTrackCache(data) {
  try {
    localStorage.setItem('track_cache', JSON.stringify({ ts: Date.now(), data }));
  } catch { /* storage full */ }
}

function loadCacheIntoState(cacheData, source) {
  let loaded = 0;
  for (const name of COACHELLA_ARTISTS) {
    const c = cacheData[name];
    if (!c || !c.tracks || !c.tracks.length) { loaded++; continue; }
    const existing = artists[name] || { ratings: [], eliminated: false, avgRating: 0 };
    artists[name] = {
      spotifyId: c.spotifyId,
      tracks: c.tracks,
      ratings: existing.ratings,
      eliminated: existing.eliminated,
      avgRating: existing.avgRating
    };
    for (const track of c.tracks) {
      const pos = Math.floor(Math.random() * (songQueue.length + 1));
      songQueue.splice(pos, 0, { artist: name, track });
    }
    loaded++;
    document.getElementById('progress-fill').style.width =
      ((loaded / COACHELLA_ARTISTS.length) * 100) + '%';
  }
  console.log(`Loaded ${loaded} artists from ${source}`);
  return loaded;
}

function chunkArray(items, size) {
  const chunks = [];
  for (let i = 0; i < items.length; i += size) {
    chunks.push(items.slice(i, i + size));
  }
  return chunks;
}

async function fetchTracksForArtistBatch(artistNames) {
  const lowered = new Set(artistNames.map(n => n.toLowerCase()));
  const query = artistNames.map(n => `artist:${n}`).join(' OR ');
  const searchRes = await spotifyFetch(
    `/search?q=${encodeURIComponent(query)}&type=track&limit=50`
  );

  const grouped = {};
  for (const name of artistNames) grouped[name] = [];
  if (!searchRes || !searchRes.tracks || !searchRes.tracks.items) {
    if (spotifyRateLimitTriggered) return grouped;
    for (const name of artistNames) {
      if (spotifyRateLimitTriggered) break;
      const single = await spotifyFetch(
        `/search?q=${encodeURIComponent('artist:' + name)}&type=track&limit=10`
      );
      if (!single || !single.tracks || !single.tracks.items || !single.tracks.items.length) continue;
      grouped[name] = single.tracks.items.slice(0, 10).map(t => ({
        id: t.id,
        uri: t.uri,
        name: t.name,
        album: t.album?.name || '',
        art: t.album?.images?.[0]?.url || '',
        duration_ms: t.duration_ms,
        _artistId: t.artists?.[0]?.id || ''
      }));
    }
    return grouped;
  }

  for (const t of searchRes.tracks.items) {
    for (const a of (t.artists || [])) {
      const matchedName = artistNames.find(n => n.toLowerCase() === (a.name || '').toLowerCase());
      if (!matchedName) continue;
      if (grouped[matchedName].length >= 10) continue;
      grouped[matchedName].push({
        id: t.id,
        uri: t.uri,
        name: t.name,
        album: t.album?.name || '',
        art: t.album?.images?.[0]?.url || '',
        duration_ms: t.duration_ms,
        _artistId: a.id || ''
      });
      if (grouped[matchedName].length >= 10 && lowered.size === 1) break;
    }
  }

  return grouped;
}

async function loadArtistTracksInBackground() {
  loadingInBackground = true;
  spotifyRateLimitTriggered = false;

  // Priority 1: Firestore shared cache (one fetch serves all users)
  const fbCached = await fbGetTrackCache();
  if (fbCached && isUsableTrackCache(fbCached)) {
    loadCacheIntoState(fbCached, 'Firestore');
    saveTrackCache(fbCached);
    updateStats();
    renderLeaderboards();
    checkFinishEligibility();
    loadingInBackground = false;
    if (songQueue.length > 0) await playNext();
    saveSession();
    showToast(`All ${Object.keys(artists).length} artists loaded!`, 'kept-toast');
    return;
  } else if (fbCached) {
    console.warn(`Ignoring incomplete Firestore cache (${countArtistsWithTracks(fbCached)} artists)`);
  }

  // Priority 2: localStorage cache (offline / faster fallback)
  const lsCached = getTrackCache();
  if (lsCached && isUsableTrackCache(lsCached)) {
    loadCacheIntoState(lsCached, 'localStorage');
    fbSaveTrackCache(lsCached);
    updateStats();
    renderLeaderboards();
    checkFinishEligibility();
    loadingInBackground = false;
    if (songQueue.length > 0) await playNext();
    saveSession();
    showToast(`All ${Object.keys(artists).length} artists loaded!`, 'kept-toast');
    return;
  } else if (lsCached) {
    console.warn(`Ignoring incomplete local cache (${countArtistsWithTracks(lsCached)} artists)`);
    localStorage.removeItem('track_cache');
  }

  // Priority 3: Fresh fetch from Spotify API
  let loaded = 0;
  let successfulLoads = 0;
  let firstSongPlayed = false;
  let consecutiveFailures = 0;
  const trackData = {};
  let initialStageDelayed = false;
  let artistsSinceStagePause = 0;

  const artistBatches = chunkArray(COACHELLA_ARTISTS, ARTIST_SEARCH_BATCH_SIZE);
  for (const batch of artistBatches) {
    if (spotifyRateLimitTriggered) break;
    if (consecutiveFailures >= 5) {
      showToast('Too many API failures. Using partial data.', 'eliminated-toast');
      break;
    }

    const batchTracks = await fetchTracksForArtistBatch(batch);

    for (const name of batch) {
      document.getElementById('progress-fill').style.width =
        ((loaded / COACHELLA_ARTISTS.length) * 100) + '%';

      const rawTracks = (batchTracks[name] || []).slice(0, 10);
      if (!rawTracks.length) {
        console.warn(`No tracks found for: ${name}`);
        loaded++;
        consecutiveFailures++;
        continue;
      }

      consecutiveFailures = 0;
      const tracks = rawTracks.map(({ _artistId, ...track }) => track);
      const spotId = rawTracks[0]._artistId || '';

      trackData[name] = { spotifyId: spotId, tracks };

      const existing = artists[name] || { ratings: [], eliminated: false, avgRating: 0 };
      artists[name] = {
        spotifyId: spotId,
        tracks,
        ratings: existing.ratings,
        eliminated: existing.eliminated,
        avgRating: existing.avgRating
      };

      for (const track of tracks) {
        const pos = Math.floor(Math.random() * (songQueue.length + 1));
        songQueue.splice(pos, 0, { artist: name, track });
      }

      loaded++;
      artistsSinceStagePause++;
      successfulLoads++;
      updateStats();
      renderLeaderboards();

      if (!firstSongPlayed && songQueue.length > 0) {
        firstSongPlayed = true;
        await playNext();
      }

      if (!initialStageDelayed && loaded >= INITIAL_ARTIST_LOAD_COUNT) {
        initialStageDelayed = true;
        showToast(`Loaded first ${INITIAL_ARTIST_LOAD_COUNT} artists. Cooling down before loading more...`, 'kept-toast');
        await sleep(STAGE_DELAY_MS);
        artistsSinceStagePause = 0;
      }
    }

    if (!spotifyRateLimitTriggered) {
      await sleep(Math.max(apiDelayMs, MIN_SEARCH_SPACING_MS));
    }

    if (initialStageDelayed && artistsSinceStagePause >= SUBSEQUENT_STAGE_ARTIST_COUNT && !spotifyRateLimitTriggered) {
      showToast('Pausing briefly to stay within Spotify limits...', 'kept-toast');
      await sleep(STAGE_DELAY_MS);
      artistsSinceStagePause = 0;
    }
  }

  if (isUsableTrackCache(trackData)) {
    saveTrackCache(trackData);
    fbSaveTrackCache(trackData);
  } else {
    console.warn(`Not caching partial Spotify data (${countArtistsWithTracks(trackData)} artists)`);
  }
  loadingInBackground = false;
  checkFinishEligibility();
  saveSession();
  if (successfulLoads === COACHELLA_ARTISTS.length) {
    showToast(`All ${successfulLoads} artists loaded!`, 'kept-toast');
  } else if (successfulLoads > 0) {
    showToast(`Loaded ${successfulLoads}/${COACHELLA_ARTISTS.length} artists (Spotify rate limited).`, 'eliminated-toast');
  } else {
    showError('Spotify is rate limiting requests right now. Wait about a minute, then retry.');
  }
}

function buildQueue() {
  songQueue = [];
  for (const [artistName, data] of Object.entries(artists)) {
    if (data.eliminated) continue;
    for (const track of data.tracks) {
      songQueue.push({ artist: artistName, track: track });
    }
  }
  // Shuffle
  for (let i = songQueue.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [songQueue[i], songQueue[j]] = [songQueue[j], songQueue[i]];
  }
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ═══════════════════════════════════════════
// WEB PLAYBACK SDK (in-browser player)
// ═══════════════════════════════════════════
let spotifyPlayer = null;
let sdkReady = false;
let webPlayerUnsupported = false;
const isEmbeddedBrowser = /Cursor|Electron/i.test(navigator.userAgent || '');

window.onSpotifyWebPlaybackSDKReady = () => { sdkReady = true; };

function initWebPlayer() {
  return new Promise((resolve) => {
    let resolved = false;
    const timeout = setTimeout(() => {
      if (!resolved) { resolved = true; console.warn('Web player timed out'); resolve(false); }
    }, 10000);

    function done(val) {
      if (!resolved) { resolved = true; clearTimeout(timeout); resolve(val); }
    }

    function tryInit() {
      if (!sdkReady) { setTimeout(tryInit, 200); return; }
      spotifyPlayer = new Spotify.Player({
        name: 'Coachella Vibe',
        getOAuthToken: cb => cb(accessToken),
        volume: 0.8
      });
      spotifyPlayer.addListener('ready', ({ device_id }) => {
        deviceId = device_id;
        console.log('Web player ready, device:', device_id);
        done(true);
      });
      spotifyPlayer.addListener('not_ready', () => {
        console.warn('Web player went offline');
        deviceId = null;
      });
      spotifyPlayer.addListener('initialization_error', ({ message }) => {
        console.error('SDK init error:', message);
        if (/keysystem|eme/i.test(message || '')) webPlayerUnsupported = true;
        done(false);
      });
      spotifyPlayer.addListener('authentication_error', ({ message }) => {
        console.warn('SDK auth warning:', message, '(player may still connect)');
      });
      spotifyPlayer.addListener('playback_error', ({ message }) => {
        console.error('SDK playback error:', message);
      });
      spotifyPlayer.addListener('player_state_changed', (state) => {
        if (!state) return;
        isPlaying = !state.paused;
        updatePlayPauseIcon();
      });
      spotifyPlayer.connect();
    }
    tryInit();
  });
}

// ═══════════════════════════════════════════
// DEVICE MANAGEMENT
// ═══════════════════════════════════════════
async function ensureDevice() {
  if (deviceId) return true;

  if (!webPlayerUnsupported) {
    // Try reconnecting the web player first
    if (spotifyPlayer) {
      try {
        await spotifyPlayer.connect();
        await sleep(1500);
        if (deviceId) return true;
      } catch (e) { console.warn('Web player reconnect failed:', e); }
    }

    // Fallback: try re-initializing the web player
    if (!deviceId) {
      const playerReady = await initWebPlayer();
      if (playerReady && deviceId) return true;
    }
  }

  // Last resort: check for external devices
  const devRes = await spotifyFetch('/me/player/devices');
  if (devRes && devRes.devices && devRes.devices.length > 0) {
    const active = devRes.devices.find(d => d.is_active);
    deviceId = active ? active.id : devRes.devices[0].id;
    return true;
  }
  showError('No playback device available. Please make sure you have Spotify Premium and allow audio in your browser.');
  return false;
}

// ═══════════════════════════════════════════
// PLAYBACK
// ═══════════════════════════════════════════
async function playNext() {
  // Remove songs from eliminated artists
  songQueue = songQueue.filter(s => !artists[s.artist]?.eliminated);

  if (songQueue.length === 0) {
    // Rebuild queue from non-eliminated artists with unplayed or less-played tracks
    buildQueue();
    if (songQueue.length === 0) {
      showToast('All songs have been played! Check your results.');
      return;
    }
  }

  currentSong = songQueue.shift();
  updateNowPlaying();

  // Play on Spotify
  const hasDevice = await ensureDevice();
  if (!hasDevice) return;

  const res = await spotifyFetch(`/me/player/play?device_id=${deviceId}`, {
    method: 'PUT',
    body: JSON.stringify({ uris: [currentSong.track.uri] })
  });

  if (res === null) {
    showError('Playback failed. Make sure Spotify is open and active.');
  } else {
    isPlaying = true;
    updatePlayPauseIcon();
    hideError();
  }
}

function updateNowPlaying() {
  if (!currentSong) return;
  document.getElementById('np-art').src = currentSong.track.art || '';
  document.getElementById('np-track').textContent = currentSong.track.name;
  document.getElementById('np-artist').textContent = currentSong.artist;

  const artistData = artists[currentSong.artist];
  if (artistData) {
    const count = artistData.ratings.length;
    document.getElementById('np-count').textContent =
      count === 0 ? 'First song from this artist' :
      `${count} song${count > 1 ? 's' : ''} rated · avg ${artistData.avgRating.toFixed(1)}`;
  }

  // Reset star highlights
  document.querySelectorAll('.star-btn').forEach(b => b.classList.remove('active'));
}

async function togglePlayPause() {
  if (spotifyPlayer) {
    await spotifyPlayer.togglePlay();
  } else if (isPlaying) {
    await spotifyFetch('/me/player/pause', { method: 'PUT' });
    isPlaying = false;
    updatePlayPauseIcon();
  } else {
    await spotifyFetch('/me/player/play', { method: 'PUT' });
    isPlaying = true;
    updatePlayPauseIcon();
  }
}

function updatePlayPauseIcon() {
  document.getElementById('play-icon').style.display = isPlaying ? 'none' : 'block';
  document.getElementById('pause-icon').style.display = isPlaying ? 'block' : 'none';
}

async function skipToNext() {
  playNext();
}

async function previousTrack() {
  // Restart current track
  if (currentSong) {
    await spotifyFetch(`/me/player/play?device_id=${deviceId}`, {
      method: 'PUT',
      body: JSON.stringify({ uris: [currentSong.track.uri] })
    });
  }
}

// ═══════════════════════════════════════════
// RATING
// ═══════════════════════════════════════════
function rate(score) {
  if (!currentSong) return;

  const artistName = currentSong.artist;
  const artistData = artists[artistName];
  if (!artistData) return;

  // Highlight selected rating
  document.querySelectorAll('.star-btn').forEach((b, i) => {
    b.classList.toggle('active', i < score);
  });

  // Record rating
  const ratingObj = {
    trackId: currentSong.track.id,
    trackName: currentSong.track.name,
    score: score
  };
  artistData.ratings.push(ratingObj);

  // Persist to Firebase (fire-and-forget)
  if (userId) {
    fbSaveRating(userId, artistName, ratingObj.trackId, ratingObj.trackName, score);
  }

  // Recalculate average
  const sum = artistData.ratings.reduce((a, r) => a + (typeof r === 'number' ? r : r.score), 0);
  artistData.avgRating = sum / artistData.ratings.length;

  totalRated++;

  // Check elimination
  if (artistData.ratings.length >= MIN_RATINGS && !artistData.eliminated) {
    if (artistData.avgRating < ELIMINATION_THRESHOLD) {
      artistData.eliminated = true;
      showToast(`❌ ${artistName} eliminated (avg: ${artistData.avgRating.toFixed(1)})`, 'eliminated-toast');
    } else if (artistData.ratings.length === MIN_RATINGS) {
      showToast(`✅ ${artistName} survives! (avg: ${artistData.avgRating.toFixed(1)})`, 'kept-toast');
    }
  }

  updateStats();
  renderLeaderboards();
  checkFinishEligibility();
  saveSession();

  // Auto-advance after brief delay
  setTimeout(() => playNext(), 800);
}

function skipSong() {
  playNext();
}

// ═══════════════════════════════════════════
// STATS & UI
// ═══════════════════════════════════════════
function updateStats() {
  const active = Object.values(artists).filter(a => !a.eliminated).length;
  const eliminated = Object.values(artists).filter(a => a.eliminated).length;

  document.getElementById('stat-remaining').textContent = active;
  document.getElementById('stat-eliminated').textContent = eliminated;
  document.getElementById('stat-rated').textContent = totalRated;

  // Progress: based on how many artists have 3+ ratings
  const total = Object.keys(artists).length;
  const evaluated = Object.values(artists).filter(a => a.ratings.length >= MIN_RATINGS).length;
  const pct = total > 0 ? (evaluated / total * 100) : 0;
  document.getElementById('progress-fill').style.width = pct + '%';
}

function renderLeaderboards() {
  // Active artists sorted by avg rating desc
  const activeArtists = Object.entries(artists)
    .filter(([_, a]) => !a.eliminated)
    .sort((a, b) => b[1].avgRating - a[1].avgRating || b[1].ratings.length - a[1].ratings.length);

  const eliminatedArtists = Object.entries(artists)
    .filter(([_, a]) => a.eliminated)
    .sort((a, b) => b[1].avgRating - a[1].avgRating);

  const allArtists = Object.entries(artists)
    .sort((a, b) => b[1].avgRating - a[1].avgRating || b[1].ratings.length - a[1].ratings.length);

  document.getElementById('leaderboard-active').innerHTML = activeArtists.map(([name, data], i) =>
    renderRow(name, data, i + 1, false)
  ).join('');

  document.getElementById('leaderboard-eliminated').innerHTML = eliminatedArtists.length > 0
    ? eliminatedArtists.map(([name, data], i) => renderRow(name, data, i + 1, true)).join('')
    : '<div style="text-align:center;color:rgba(255,255,255,0.3);padding:30px;">No artists eliminated yet</div>';

  document.getElementById('leaderboard-all').innerHTML = allArtists.map(([name, data], i) =>
    renderRow(name, data, i + 1, data.eliminated)
  ).join('');
}

function renderRow(name, data, rank, isEliminated) {
  const statusClass = isEliminated ? 'eliminated' :
    data.ratings.length >= MIN_RATINGS ? 'kept' : 'pending';
  const statusText = isEliminated ? 'OUT' :
    data.ratings.length >= MIN_RATINGS ? 'IN' : `${data.ratings.length}/${MIN_RATINGS}`;

  return `
    <div class="lb-row ${isEliminated ? 'eliminated' : ''}">
      <div class="lb-rank">${rank}</div>
      <div class="lb-info">
        <div class="lb-name">${name}</div>
        <div class="lb-meta">${data.ratings.length} rated · ${data.tracks.length} tracks available</div>
      </div>
      <div class="lb-avg">${data.ratings.length > 0 ? data.avgRating.toFixed(1) : '—'}</div>
      <div class="lb-status ${statusClass}">${statusText}</div>
    </div>
  `;
}

function switchTab(tab) {
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

  event.target.classList.add('active');
  document.getElementById(`tab-${tab}`).classList.add('active');

  if (tab === 'community') loadCommunityTab();
}

// ═══════════════════════════════════════════
// COMMUNITY TAB
// ═══════════════════════════════════════════
async function loadCommunityTab() {
  const container = document.getElementById('community-content');
  container.innerHTML = '<div style="text-align:center;padding:30px;color:rgba(255,255,255,0.4)">Loading community ratings...</div>';

  const [allRatings, allUsers] = await Promise.all([fbLoadAllRatings(), fbLoadAllUsers()]);

  if (!allRatings.length) {
    container.innerHTML = '<div style="text-align:center;padding:30px;color:rgba(255,255,255,0.4)">No community ratings yet. Be the first!</div>';
    return;
  }

  // Build global artist averages + per-user data
  const artistMap = {}; // { artistName: { scores: [], raters: Set } }
  const userMap = {};   // { spotifyId: { ratings: [], ... } }

  for (const r of allRatings) {
    if (!artistMap[r.artist_name]) artistMap[r.artist_name] = { scores: [], raters: new Set() };
    artistMap[r.artist_name].scores.push(r.score);
    artistMap[r.artist_name].raters.add(r.spotify_id);

    if (!userMap[r.spotify_id]) userMap[r.spotify_id] = { count: 0 };
    userMap[r.spotify_id].count++;
  }

  // Sort artists by average rating descending
  const sorted = Object.entries(artistMap)
    .map(([name, data]) => ({
      name,
      avg: data.scores.reduce((a, b) => a + b, 0) / data.scores.length,
      count: data.scores.length,
      raters: [...data.raters]
    }))
    .sort((a, b) => b.avg - a.avg);

  // Top raters section
  const topRaters = Object.entries(userMap)
    .map(([id, data]) => ({ id, count: data.count, ...allUsers[id] }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);

  let html = '<div style="margin-bottom:16px"><h3 style="font-size:0.9rem;color:rgba(255,255,255,0.5);margin-bottom:10px;font-weight:600">TOP RATERS</h3><div class="top-raters">';

  for (const rater of topRaters) {
    const name = rater.display_name || rater.id;
    const avatar = rater.avatar_url || '';
    html += `<div class="rater-chip" onclick="showUserDetail('${rater.id}')">`;
    if (avatar) html += `<img src="${avatar}" alt="">`;
    else html += `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.1)"></div>`;
    html += `<div><div class="rater-name">${name}</div><div class="rater-count">${rater.count} ratings</div></div></div>`;
  }

  html += '</div></div>';
  html += '<h3 style="font-size:0.9rem;color:rgba(255,255,255,0.5);margin-bottom:10px;font-weight:600">GLOBAL ARTIST RANKINGS</h3>';

  for (let i = 0; i < sorted.length; i++) {
    const a = sorted[i];
    const stars = '★'.repeat(Math.round(a.avg)) + '☆'.repeat(5 - Math.round(a.avg));
    const raterNames = a.raters.map(id => {
      const u = allUsers[id];
      const n = u ? u.display_name : id.slice(0, 8);
      return `<span onclick="showUserDetail('${id}')">${n}</span>`;
    }).join(', ');

    html += `<div class="community-artist-row">
      <div style="font-size:0.75rem;color:rgba(255,255,255,0.3);width:24px;text-align:center">${i + 1}</div>
      <div style="flex:1">
        <div style="font-weight:600;font-size:0.95rem">${a.name}</div>
        <div class="community-raters">Rated by: ${raterNames}</div>
      </div>
      <div style="text-align:right">
        <div style="font-size:0.9rem;color:var(--desert-gold)">${stars}</div>
        <div style="font-size:0.8rem;color:rgba(255,255,255,0.5)">${a.avg.toFixed(1)} · ${a.count} ratings</div>
      </div>
    </div>`;
  }

  container.innerHTML = html;
}

async function showUserDetail(spotifyId) {
  const container = document.getElementById('community-content');
  container.innerHTML = '<div style="text-align:center;padding:30px;color:rgba(255,255,255,0.4)">Loading...</div>';

  const [allRatings, allUsers] = await Promise.all([fbLoadAllRatings(), fbLoadAllUsers()]);
  const user = allUsers[spotifyId] || {};
  const userRatings = allRatings.filter(r => r.spotify_id === spotifyId);

  if (!userRatings.length) {
    container.innerHTML = `<button class="back-btn" onclick="loadCommunityTab()" style="margin-bottom:12px">← Back</button>
      <div style="text-align:center;padding:30px;color:rgba(255,255,255,0.4)">No ratings from this user yet.</div>`;
    return;
  }

  // Group by artist
  const byArtist = {};
  for (const r of userRatings) {
    if (!byArtist[r.artist_name]) byArtist[r.artist_name] = [];
    byArtist[r.artist_name].push(r);
  }

  const sorted = Object.entries(byArtist)
    .map(([name, ratings]) => ({
      name,
      avg: ratings.reduce((a, r) => a + r.score, 0) / ratings.length,
      count: ratings.length
    }))
    .sort((a, b) => b.avg - a.avg);

  const displayName = user.display_name || spotifyId;
  const avatar = user.avatar_url || '';
  const isMe = spotifyId === userId;

  let html = `<div class="user-detail-header">`;
  html += `<div class="user-detail-avatar">`;
  if (avatar) html += `<img src="${avatar}" alt="">`;
  html += `</div>`;
  html += `<div>
    <div class="user-detail-name">${displayName}${isMe ? ' (you)' : ''}</div>
    <div class="user-detail-meta">${userRatings.length} ratings · ${sorted.length} artists</div>
  </div>`;
  html += `<button class="back-btn" onclick="loadCommunityTab()">← Back</button>`;
  html += `</div>`;

  for (let i = 0; i < sorted.length; i++) {
    const a = sorted[i];
    const stars = '★'.repeat(Math.round(a.avg)) + '☆'.repeat(5 - Math.round(a.avg));
    html += `<div class="community-artist-row">
      <div style="font-size:0.75rem;color:rgba(255,255,255,0.3);width:24px;text-align:center">${i + 1}</div>
      <div style="flex:1;font-weight:600;font-size:0.95rem">${a.name}</div>
      <div style="text-align:right">
        <div style="font-size:0.9rem;color:var(--desert-gold)">${stars}</div>
        <div style="font-size:0.8rem;color:rgba(255,255,255,0.5)">${a.avg.toFixed(1)} · ${a.count} tracks</div>
      </div>
    </div>`;
  }

  container.innerHTML = html;
}

function checkFinishEligibility() {
  const total = Object.keys(artists).length;
  const evaluated = Object.values(artists).filter(a => a.ratings.length >= MIN_RATINGS || a.eliminated).length;
  const btn = document.getElementById('btn-finish');
  btn.disabled = evaluated < total;
}

// ═══════════════════════════════════════════
// FINISH / RESULTS
// ═══════════════════════════════════════════
async function finishSession() {
  // Pause playback
  await spotifyFetch('/me/player/pause', { method: 'PUT' }).catch(() => {});

  const survivors = Object.entries(artists)
    .filter(([_, a]) => !a.eliminated)
    .sort((a, b) => b[1].avgRating - a[1].avgRating);

  const eliminated = Object.entries(artists).filter(([_, a]) => a.eliminated);

  document.getElementById('player-section').style.display = 'none';
  document.getElementById('results-screen').style.display = 'block';

  document.getElementById('results-summary').textContent =
    `${survivors.length} artists survived out of ${Object.keys(artists).length}. ${eliminated.length} eliminated.`;

  document.getElementById('results-leaderboard').innerHTML =
    survivors.map(([name, data], i) => renderRow(name, data, i + 1, false)).join('');
}

async function createPlaylist() {
  showLoading('Creating your Coachella playlist...');

  const survivors = Object.entries(artists)
    .filter(([_, a]) => !a.eliminated)
    .sort((a, b) => b[1].avgRating - a[1].avgRating);

  // Create playlist
  const playlist = await spotifyFetch('/me/playlists', {
    method: 'POST',
    body: JSON.stringify({
      name: 'My Coachella 2026 Lineup 🌴',
      description: `Curated by Vibe Code — ${survivors.length} artists, rated and approved.`,
      public: true
    })
  });

  if (!playlist || !playlist.id) {
    hideLoading();
    showError('Failed to create playlist.');
    return;
  }

  // Collect top-rated tracks from each surviving artist
  const trackUris = [];
  for (const [name, data] of survivors) {
    // Get the highest-rated tracks for this artist
    const ratedTracks = data.ratings
      .sort((a, b) => b.score - a.score)
      .slice(0, 3); // Top 3 rated tracks

    for (const r of ratedTracks) {
      const trackObj = data.tracks.find(t => t.id === r.trackId);
      if (trackObj) {
        trackUris.push(trackObj.uri);
      }
    }
  }

  // Deduplicate
  const uniqueUris = [...new Set(trackUris)];

  // Add tracks in batches of 100
  for (let i = 0; i < uniqueUris.length; i += 100) {
    const batch = uniqueUris.slice(i, i + 100);
    await spotifyFetch(`/playlists/${playlist.id}/items`, {
      method: 'POST',
      body: JSON.stringify({ uris: batch })
    });
  }

  hideLoading();
  showToast(`🎉 Playlist created with ${uniqueUris.length} tracks!`, 'kept-toast');

  // Update button
  const btn = document.getElementById('btn-create-playlist');
  btn.textContent = '✓ Playlist Created!';
  btn.style.background = '#2D6A4F';
  btn.onclick = () => window.open(playlist.external_urls?.spotify || 'https://open.spotify.com', '_blank');
}

function restartSession() {
  localStorage.removeItem('vibe_session');
  artists = {};
  totalRated = 0;
  songQueue = [];
  currentSong = null;
  document.getElementById('results-screen').style.display = 'none';
  document.getElementById('player-section').style.display = 'block';
  loadArtistTracksInBackground();
}

// ═══════════════════════════════════════════
// SESSION PERSISTENCE
// ═══════════════════════════════════════════
function saveSession() {
  try {
    localStorage.setItem('vibe_session', JSON.stringify({
      artists: artists,
      totalRated: totalRated,
      songQueue: songQueue.slice(0, 50) // Only save next 50 to save space
    }));
  } catch(e) {
    console.warn('Could not save session:', e);
  }
}

// ═══════════════════════════════════════════
// UI HELPERS
// ═══════════════════════════════════════════
function showLoading(text) {
  document.getElementById('loading-text').textContent = text || 'Loading...';
  document.getElementById('loading').classList.add('active');
}

function hideLoading() {
  document.getElementById('loading').classList.remove('active');
}

function showError(msg) {
  const el = document.getElementById('error-msg');
  el.textContent = msg;
  el.classList.add('show');
}

function hideError() {
  document.getElementById('error-msg').classList.remove('show');
}

function showToast(msg, extraClass = '') {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.className = 'toast ' + extraClass;
  setTimeout(() => toast.classList.add('show'), 10);
  setTimeout(() => toast.classList.remove('show'), 3500);
}

// ═══════════════════════════════════════════
// BOOT
// ═══════════════════════════════════════════
(async function boot() {
  // Check for auth code in URL
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');

  if (code) {
    showLoading('Authenticating with Spotify...');
    await exchangeCode(code);
    return;
  }

  const token = localStorage.getItem('spotify_token');
  const tokenTime = parseInt(localStorage.getItem('spotify_token_time') || '0');
  const isExpired = Date.now() - tokenTime > 3500000;
  const savedScopes = localStorage.getItem('spotify_scopes') || '';
  const scopesChanged = savedScopes !== SCOPES;
  refreshToken = localStorage.getItem('spotify_refresh_token');

  if (scopesChanged && refreshToken) {
    localStorage.removeItem('spotify_token');
    localStorage.removeItem('spotify_refresh_token');
    localStorage.removeItem('spotify_scopes');
    document.getElementById('login-screen').style.display = 'flex';
    return;
  }

  if (token && !isExpired) {
    accessToken = token;
    const me = await spotifyFetch('/me');
    if (me) {
      await initApp();
      return;
    }
  }

  if (refreshToken) {
    const refreshed = await refreshAccessToken();
    if (refreshed) {
      await initApp();
      return;
    }
  }

  document.getElementById('login-screen').style.display = 'flex';
})();
</script>

</body>
</html>
